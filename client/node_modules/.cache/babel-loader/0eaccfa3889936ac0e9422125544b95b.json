{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar pipeable_1 = require(\"./pipeable\");\n/**\n * @since 2.0.0\n */\n\n\nexports.URI = 'Task';\n/**\n * @since 2.0.0\n */\n\nexports.never = function () {\n  return new Promise(function (_) {\n    return undefined;\n  });\n};\n/**\n * @since 2.0.0\n */\n\n\nfunction getSemigroup(S) {\n  return {\n    concat: function concat(x, y) {\n      return function () {\n        return x().then(function (rx) {\n          return y().then(function (ry) {\n            return S.concat(rx, ry);\n          });\n        });\n      };\n    }\n  };\n}\n\nexports.getSemigroup = getSemigroup;\n/**\n * @since 2.0.0\n */\n\nfunction getMonoid(M) {\n  return {\n    concat: getSemigroup(M).concat,\n    empty: exports.task.of(M.empty)\n  };\n}\n\nexports.getMonoid = getMonoid;\n/**\n * @since 2.0.0\n */\n\nfunction getRaceMonoid() {\n  return {\n    concat: function concat(x, y) {\n      return function () {\n        return new Promise(function (resolve, reject) {\n          var running = true;\n\n          var resolveFirst = function resolveFirst(a) {\n            if (running) {\n              running = false;\n              resolve(a);\n            }\n          };\n\n          var rejectFirst = function rejectFirst(e) {\n            if (running) {\n              running = false;\n              reject(e);\n            }\n          };\n\n          x().then(resolveFirst, rejectFirst);\n          y().then(resolveFirst, rejectFirst);\n        });\n      };\n    },\n    empty: exports.never\n  };\n}\n\nexports.getRaceMonoid = getRaceMonoid;\n/**\n * @since 2.0.0\n */\n\nfunction delay(millis) {\n  return function (ma) {\n    return function () {\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          // tslint:disable-next-line: no-floating-promises\n          ma().then(resolve);\n        }, millis);\n      });\n    };\n  };\n}\n\nexports.delay = delay;\n/**\n * @since 2.0.0\n */\n\nfunction fromIO(ma) {\n  return function () {\n    return Promise.resolve(ma());\n  };\n}\n\nexports.fromIO = fromIO;\n\nvar identity = function identity(a) {\n  return a;\n};\n/**\n * @since 2.0.0\n */\n\n\nfunction of(a) {\n  return function () {\n    return Promise.resolve(a);\n  };\n}\n\nexports.of = of;\n/**\n * @since 2.0.0\n */\n\nexports.task = {\n  URI: exports.URI,\n  map: function map(ma, f) {\n    return function () {\n      return ma().then(f);\n    };\n  },\n  of: of,\n  ap: function ap(mab, ma) {\n    return function () {\n      return Promise.all([mab(), ma()]).then(function (_a) {\n        var f = _a[0],\n            a = _a[1];\n        return f(a);\n      });\n    };\n  },\n  chain: function chain(ma, f) {\n    return function () {\n      return ma().then(function (a) {\n        return f(a)();\n      });\n    };\n  },\n  fromIO: fromIO,\n  fromTask: identity\n};\n/**\n * Like `Task` but `ap` is sequential\n *\n * @since 2.0.0\n */\n\nexports.taskSeq = __assign(__assign({}, exports.task), {\n  ap: function ap(mab, ma) {\n    return function () {\n      return mab().then(function (f) {\n        return ma().then(function (a) {\n          return f(a);\n        });\n      });\n    };\n  }\n});\n\nvar _a = pipeable_1.pipeable(exports.task),\n    ap = _a.ap,\n    apFirst = _a.apFirst,\n    apSecond = _a.apSecond,\n    chain = _a.chain,\n    chainFirst = _a.chainFirst,\n    flatten = _a.flatten,\n    map = _a.map;\n\nexports.ap = ap;\nexports.apFirst = apFirst;\nexports.apSecond = apSecond;\nexports.chain = chain;\nexports.chainFirst = chainFirst;\nexports.flatten = flatten;\nexports.map = map;","map":null,"metadata":{},"sourceType":"script"}