{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar function_1 = require(\"./function\");\n\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return a;\n\n    case 2:\n      return ab(a);\n\n    case 3:\n      return bc(ab(a));\n\n    case 4:\n      return cd(bc(ab(a)));\n\n    case 5:\n      return de(cd(bc(ab(a))));\n\n    case 6:\n      return ef(de(cd(bc(ab(a)))));\n\n    case 7:\n      return fg(ef(de(cd(bc(ab(a))))));\n\n    case 8:\n      return gh(fg(ef(de(cd(bc(ab(a)))))));\n\n    case 9:\n      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n\n    case 10:\n      return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));\n  }\n}\n\nexports.pipe = pipe;\n\nvar isFunctor = function isFunctor(I) {\n  return typeof I.map === 'function';\n};\n\nvar isContravariant = function isContravariant(I) {\n  return typeof I.contramap === 'function';\n};\n\nvar isFunctorWithIndex = function isFunctorWithIndex(I) {\n  return typeof I.mapWithIndex === 'function';\n};\n\nvar isApply = function isApply(I) {\n  return typeof I.ap === 'function';\n};\n\nvar isChain = function isChain(I) {\n  return typeof I.chain === 'function';\n};\n\nvar isBifunctor = function isBifunctor(I) {\n  return typeof I.bimap === 'function';\n};\n\nvar isExtend = function isExtend(I) {\n  return typeof I.extend === 'function';\n};\n\nvar isFoldable = function isFoldable(I) {\n  return typeof I.reduce === 'function';\n};\n\nvar isFoldableWithIndex = function isFoldableWithIndex(I) {\n  return typeof I.reduceWithIndex === 'function';\n};\n\nvar isAlt = function isAlt(I) {\n  return typeof I.alt === 'function';\n};\n\nvar isCompactable = function isCompactable(I) {\n  return typeof I.compact === 'function';\n};\n\nvar isFilterable = function isFilterable(I) {\n  return typeof I.filter === 'function';\n};\n\nvar isFilterableWithIndex = function isFilterableWithIndex(I) {\n  return typeof I.filterWithIndex === 'function';\n};\n\nvar isProfunctor = function isProfunctor(I) {\n  return typeof I.promap === 'function';\n};\n\nvar isSemigroupoid = function isSemigroupoid(I) {\n  return typeof I.compose === 'function';\n};\n\nvar isMonadThrow = function isMonadThrow(I) {\n  return typeof I.throwError === 'function';\n};\n\nfunction pipeable(I) {\n  var r = {};\n\n  if (isFunctor(I)) {\n    var map = function map(f) {\n      return function (fa) {\n        return I.map(fa, f);\n      };\n    };\n\n    r.map = map;\n  }\n\n  if (isContravariant(I)) {\n    var contramap = function contramap(f) {\n      return function (fa) {\n        return I.contramap(fa, f);\n      };\n    };\n\n    r.contramap = contramap;\n  }\n\n  if (isFunctorWithIndex(I)) {\n    var mapWithIndex = function mapWithIndex(f) {\n      return function (fa) {\n        return I.mapWithIndex(fa, f);\n      };\n    };\n\n    r.mapWithIndex = mapWithIndex;\n  }\n\n  if (isApply(I)) {\n    var ap = function ap(fa) {\n      return function (fab) {\n        return I.ap(fab, fa);\n      };\n    };\n\n    var apFirst = function apFirst(fb) {\n      return function (fa) {\n        return I.ap(I.map(fa, function (a) {\n          return function () {\n            return a;\n          };\n        }), fb);\n      };\n    };\n\n    r.ap = ap;\n    r.apFirst = apFirst;\n\n    r.apSecond = function (fb) {\n      return function (fa) {\n        return I.ap(I.map(fa, function () {\n          return function (b) {\n            return b;\n          };\n        }), fb);\n      };\n    };\n  }\n\n  if (isChain(I)) {\n    var chain = function chain(f) {\n      return function (ma) {\n        return I.chain(ma, f);\n      };\n    };\n\n    var chainFirst = function chainFirst(f) {\n      return function (ma) {\n        return I.chain(ma, function (a) {\n          return I.map(f(a), function () {\n            return a;\n          });\n        });\n      };\n    };\n\n    var flatten = function flatten(mma) {\n      return I.chain(mma, function_1.identity);\n    };\n\n    r.chain = chain;\n    r.chainFirst = chainFirst;\n    r.flatten = flatten;\n  }\n\n  if (isBifunctor(I)) {\n    var bimap = function bimap(f, g) {\n      return function (fa) {\n        return I.bimap(fa, f, g);\n      };\n    };\n\n    var mapLeft = function mapLeft(f) {\n      return function (fa) {\n        return I.mapLeft(fa, f);\n      };\n    };\n\n    r.bimap = bimap;\n    r.mapLeft = mapLeft;\n  }\n\n  if (isExtend(I)) {\n    var extend = function extend(f) {\n      return function (wa) {\n        return I.extend(wa, f);\n      };\n    };\n\n    var duplicate = function duplicate(wa) {\n      return I.extend(wa, function_1.identity);\n    };\n\n    r.extend = extend;\n    r.duplicate = duplicate;\n  }\n\n  if (isFoldable(I)) {\n    var reduce = function reduce(b, f) {\n      return function (fa) {\n        return I.reduce(fa, b, f);\n      };\n    };\n\n    var foldMap = function foldMap(M) {\n      var foldMapM = I.foldMap(M);\n      return function (f) {\n        return function (fa) {\n          return foldMapM(fa, f);\n        };\n      };\n    };\n\n    var reduceRight = function reduceRight(b, f) {\n      return function (fa) {\n        return I.reduceRight(fa, b, f);\n      };\n    };\n\n    r.reduce = reduce;\n    r.foldMap = foldMap;\n    r.reduceRight = reduceRight;\n  }\n\n  if (isFoldableWithIndex(I)) {\n    var reduceWithIndex = function reduceWithIndex(b, f) {\n      return function (fa) {\n        return I.reduceWithIndex(fa, b, f);\n      };\n    };\n\n    var foldMapWithIndex = function foldMapWithIndex(M) {\n      var foldMapM = I.foldMapWithIndex(M);\n      return function (f) {\n        return function (fa) {\n          return foldMapM(fa, f);\n        };\n      };\n    };\n\n    var reduceRightWithIndex = function reduceRightWithIndex(b, f) {\n      return function (fa) {\n        return I.reduceRightWithIndex(fa, b, f);\n      };\n    };\n\n    r.reduceWithIndex = reduceWithIndex;\n    r.foldMapWithIndex = foldMapWithIndex;\n    r.reduceRightWithIndex = reduceRightWithIndex;\n  }\n\n  if (isAlt(I)) {\n    var alt = function alt(that) {\n      return function (fa) {\n        return I.alt(fa, that);\n      };\n    };\n\n    r.alt = alt;\n  }\n\n  if (isCompactable(I)) {\n    r.compact = I.compact;\n    r.separate = I.separate;\n  }\n\n  if (isFilterable(I)) {\n    var filter = function filter(predicate) {\n      return function (fa) {\n        return I.filter(fa, predicate);\n      };\n    };\n\n    var filterMap = function filterMap(f) {\n      return function (fa) {\n        return I.filterMap(fa, f);\n      };\n    };\n\n    var partition = function partition(predicate) {\n      return function (fa) {\n        return I.partition(fa, predicate);\n      };\n    };\n\n    var partitionMap = function partitionMap(f) {\n      return function (fa) {\n        return I.partitionMap(fa, f);\n      };\n    };\n\n    r.filter = filter;\n    r.filterMap = filterMap;\n    r.partition = partition;\n    r.partitionMap = partitionMap;\n  }\n\n  if (isFilterableWithIndex(I)) {\n    var filterWithIndex = function filterWithIndex(predicateWithIndex) {\n      return function (fa) {\n        return I.filterWithIndex(fa, predicateWithIndex);\n      };\n    };\n\n    var filterMapWithIndex = function filterMapWithIndex(f) {\n      return function (fa) {\n        return I.filterMapWithIndex(fa, f);\n      };\n    };\n\n    var partitionWithIndex = function partitionWithIndex(predicateWithIndex) {\n      return function (fa) {\n        return I.partitionWithIndex(fa, predicateWithIndex);\n      };\n    };\n\n    var partitionMapWithIndex = function partitionMapWithIndex(f) {\n      return function (fa) {\n        return I.partitionMapWithIndex(fa, f);\n      };\n    };\n\n    r.filterWithIndex = filterWithIndex;\n    r.filterMapWithIndex = filterMapWithIndex;\n    r.partitionWithIndex = partitionWithIndex;\n    r.partitionMapWithIndex = partitionMapWithIndex;\n  }\n\n  if (isProfunctor(I)) {\n    var promap = function promap(f, g) {\n      return function (fa) {\n        return I.promap(fa, f, g);\n      };\n    };\n\n    r.promap = promap;\n  }\n\n  if (isSemigroupoid(I)) {\n    var compose = function compose(that) {\n      return function (fa) {\n        return I.compose(fa, that);\n      };\n    };\n\n    r.compose = compose;\n  }\n\n  if (isMonadThrow(I)) {\n    var fromOption = function fromOption(onNone) {\n      return function (ma) {\n        return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);\n      };\n    };\n\n    var fromEither = function fromEither(ma) {\n      return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);\n    };\n\n    var fromPredicate = function fromPredicate(predicate, onFalse) {\n      return function (a) {\n        return predicate(a) ? I.of(a) : I.throwError(onFalse(a));\n      };\n    };\n\n    var filterOrElse = function filterOrElse(predicate, onFalse) {\n      return function (ma) {\n        return I.chain(ma, function (a) {\n          return predicate(a) ? I.of(a) : I.throwError(onFalse(a));\n        });\n      };\n    };\n\n    r.fromOption = fromOption;\n    r.fromEither = fromEither;\n    r.fromPredicate = fromPredicate;\n    r.filterOrElse = filterOrElse;\n  }\n\n  return r;\n}\n\nexports.pipeable = pipeable;","map":null,"metadata":{},"sourceType":"script"}