{"ast":null,"code":"\"use strict\";\n/**\n * @file Represents a value of one of two possible types (a disjoint union).\n *\n * An instance of `Either` is either an instance of `Left` or `Right`.\n *\n * A common use of `Either` is as an alternative to `Option` for dealing with possible missing values. In this usage,\n * `None` is replaced with a `Left` which can contain useful information. `Right` takes the place of `Some`. Convention\n * dictates that `Left` is used for failure and `Right` is used for success.\n *\n * For example, you could use `Either<string, number>` to detect whether a received input is a `string` or a `number`.\n *\n * ```ts\n * const parse = (errorMessage: string) => (input: string): Either<string, number> => {\n *   const n = parseInt(input, 10)\n *   return isNaN(n) ? left(errorMessage) : right(n)\n * }\n * ```\n *\n * `Either` is right-biased, which means that `Right` is assumed to be the default case to operate on. If it is `Left`,\n * operations like `map`, `chain`, ... return the `Left` value unchanged:\n *\n * ```ts\n * import { either } from 'fp-ts/lib/Either'\n *\n * either.map(right(12), double) // right(24)\n * either.map(left(23), double)  // left(23)\n * ```\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ChainRec_1 = require(\"./ChainRec\");\n\nvar pipeable_1 = require(\"./pipeable\");\n/**\n * @since 2.0.0\n */\n\n\nexports.URI = 'Either';\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure\n *\n * @since 2.0.0\n */\n\nfunction left(e) {\n  return {\n    _tag: 'Left',\n    left: e\n  };\n}\n\nexports.left = left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure\n *\n * @since 2.0.0\n */\n\nfunction right(a) {\n  return {\n    _tag: 'Right',\n    right: a\n  };\n}\n\nexports.right = right;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/lib/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @since 2.0.0\n */\n\nfunction fromNullable(e) {\n  return function (a) {\n    return a == null ? left(e) : right(a);\n  };\n}\n\nexports.fromNullable = fromNullable;\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\n\nfunction toError(e) {\n  return e instanceof Error ? e : new Error(String(e));\n}\n\nexports.toError = toError;\n/**\n * Constructs a new `Either` from a function that might throw\n *\n * @example\n * import { Either, left, right, tryCatch } from 'fp-ts/lib/Either'\n *\n * const unsafeHead = <A>(as: Array<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: Array<A>): Either<Error, A> => {\n *   return tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n * }\n *\n * assert.deepStrictEqual(head([]), left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), right(1))\n *\n * @since 2.0.0\n */\n\nfunction tryCatch(f, onError) {\n  try {\n    return right(f());\n  } catch (e) {\n    return left(onError(e));\n  }\n}\n\nexports.tryCatch = tryCatch;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { fold, left, right } from 'fp-ts/lib/Either'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     fold(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     fold(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @since 2.0.0\n */\n\nfunction fold(onLeft, onRight) {\n  return function (ma) {\n    return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n  };\n}\n\nexports.fold = fold;\n/**\n * @since 2.0.0\n */\n\nfunction getShow(SE, SA) {\n  return {\n    show: function show(ma) {\n      return isLeft(ma) ? \"left(\" + SE.show(ma.left) + \")\" : \"right(\" + SA.show(ma.right) + \")\";\n    }\n  };\n}\n\nexports.getShow = getShow;\n/**\n * @since 2.0.0\n */\n\nfunction getEq(EL, EA) {\n  return {\n    equals: function equals(x, y) {\n      return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n  };\n}\n\nexports.getEq = getEq;\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * appended using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getSemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n *\n * @since 2.0.0\n */\n\nfunction getSemigroup(S) {\n  return {\n    concat: function concat(x, y) {\n      return isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right));\n    }\n  };\n}\n\nexports.getSemigroup = getSemigroup;\n/**\n * `Apply` semigroup\n *\n * @example\n * import { getApplySemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), left('a'))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), left('b'))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n *\n * @since 2.0.0\n */\n\nfunction getApplySemigroup(S) {\n  return {\n    concat: function concat(x, y) {\n      return isLeft(x) ? x : isLeft(y) ? y : right(S.concat(x.right, y.right));\n    }\n  };\n}\n\nexports.getApplySemigroup = getApplySemigroup;\n/**\n * @since 2.0.0\n */\n\nfunction getApplyMonoid(M) {\n  return __assign(__assign({}, getApplySemigroup(M)), {\n    empty: right(M.empty)\n  });\n}\n\nexports.getApplyMonoid = getApplyMonoid;\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise\n *\n * @since 2.0.0\n */\n\nfunction isLeft(ma) {\n  switch (ma._tag) {\n    case 'Left':\n      return true;\n\n    case 'Right':\n      return false;\n  }\n}\n\nexports.isLeft = isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise\n *\n * @since 2.0.0\n */\n\nfunction isRight(ma) {\n  return isLeft(ma) ? false : true;\n}\n\nexports.isRight = isRight;\n/**\n * @since 2.0.0\n */\n\nfunction swap(ma) {\n  return isLeft(ma) ? right(ma.left) : left(ma.right);\n}\n\nexports.swap = swap;\n/**\n * @since 2.0.0\n */\n\nfunction orElse(onLeft) {\n  return function (ma) {\n    return isLeft(ma) ? onLeft(ma.left) : ma;\n  };\n}\n\nexports.orElse = orElse;\n/**\n * @since 2.0.0\n */\n\nfunction getOrElse(onLeft) {\n  return function (ma) {\n    return isLeft(ma) ? onLeft(ma.left) : ma.right;\n  };\n}\n\nexports.getOrElse = getOrElse;\n/**\n * @since 2.0.0\n */\n\nfunction elem(E) {\n  return function (a, ma) {\n    return isLeft(ma) ? false : E.equals(a, ma.right);\n  };\n}\n\nexports.elem = elem;\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/lib/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\n\nfunction exists(predicate) {\n  return function (ma) {\n    return isLeft(ma) ? false : predicate(ma.right);\n  };\n}\n\nexports.exists = exists;\n/**\n * Converts a JavaScript Object Notation (JSON) string into an object.\n *\n * @example\n * import { parseJSON, toError, right, left } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(parseJSON('{\"a\":1}', toError), right({ a: 1 }))\n * assert.deepStrictEqual(parseJSON('{\"a\":}', toError), left(new SyntaxError('Unexpected token } in JSON at position 5')))\n *\n * @since 2.0.0\n */\n\nfunction parseJSON(s, onError) {\n  return tryCatch(function () {\n    return JSON.parse(s);\n  }, onError);\n}\n\nexports.parseJSON = parseJSON;\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import { stringifyJSON, toError, right, left } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(stringifyJSON({ a: 1 }, toError), right('{\"a\":1}'))\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(stringifyJSON(circular, toError), left(new TypeError('Converting circular structure to JSON')))\n *\n * @since 2.0.0\n */\n\nfunction stringifyJSON(u, onError) {\n  return tryCatch(function () {\n    return JSON.stringify(u);\n  }, onError);\n}\n\nexports.stringifyJSON = stringifyJSON;\nvar phantom = undefined;\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @since 2.0.0\n */\n\nfunction getWitherable(M) {\n  var empty = left(M.empty);\n\n  var compact = function compact(ma) {\n    return isLeft(ma) ? ma : ma.right._tag === 'None' ? left(M.empty) : right(ma.right.value);\n  };\n\n  var separate = function separate(ma) {\n    return isLeft(ma) ? {\n      left: ma,\n      right: ma\n    } : isLeft(ma.right) ? {\n      left: right(ma.right.left),\n      right: empty\n    } : {\n      left: empty,\n      right: right(ma.right.right)\n    };\n  };\n\n  var partitionMap = function partitionMap(ma, f) {\n    if (isLeft(ma)) {\n      return {\n        left: ma,\n        right: ma\n      };\n    }\n\n    var e = f(ma.right);\n    return isLeft(e) ? {\n      left: right(e.left),\n      right: empty\n    } : {\n      left: empty,\n      right: right(e.right)\n    };\n  };\n\n  var partition = function partition(ma, p) {\n    return isLeft(ma) ? {\n      left: ma,\n      right: ma\n    } : p(ma.right) ? {\n      left: empty,\n      right: right(ma.right)\n    } : {\n      left: right(ma.right),\n      right: empty\n    };\n  };\n\n  var filterMap = function filterMap(ma, f) {\n    if (isLeft(ma)) {\n      return ma;\n    }\n\n    var ob = f(ma.right);\n    return ob._tag === 'None' ? left(M.empty) : right(ob.value);\n  };\n\n  var filter = function filter(ma, predicate) {\n    return isLeft(ma) ? ma : predicate(ma.right) ? ma : left(M.empty);\n  };\n\n  var wither = function wither(F) {\n    var traverseF = exports.either.traverse(F);\n    return function (ma, f) {\n      return F.map(traverseF(ma, f), compact);\n    };\n  };\n\n  var wilt = function wilt(F) {\n    var traverseF = exports.either.traverse(F);\n    return function (ma, f) {\n      return F.map(traverseF(ma, f), separate);\n    };\n  };\n\n  return {\n    URI: exports.URI,\n    _E: phantom,\n    map: exports.either.map,\n    compact: compact,\n    separate: separate,\n    filter: filter,\n    filterMap: filterMap,\n    partition: partition,\n    partitionMap: partitionMap,\n    traverse: exports.either.traverse,\n    sequence: exports.either.sequence,\n    reduce: exports.either.reduce,\n    foldMap: exports.either.foldMap,\n    reduceRight: exports.either.reduceRight,\n    wither: wither,\n    wilt: wilt\n  };\n}\n\nexports.getWitherable = getWitherable;\n/**\n * @since 2.0.0\n */\n\nfunction getValidation(S) {\n  return {\n    URI: exports.URI,\n    _E: phantom,\n    map: exports.either.map,\n    of: exports.either.of,\n    ap: function ap(mab, ma) {\n      return isLeft(mab) ? isLeft(ma) ? left(S.concat(mab.left, ma.left)) : mab : isLeft(ma) ? ma : right(mab.right(ma.right));\n    },\n    chain: exports.either.chain,\n    alt: function alt(fx, f) {\n      if (isRight(fx)) {\n        return fx;\n      }\n\n      var fy = f();\n      return isLeft(fy) ? left(S.concat(fx.left, fy.left)) : fy;\n    }\n  };\n}\n\nexports.getValidation = getValidation;\n/**\n * @since 2.0.0\n */\n\nfunction getValidationSemigroup(SE, SA) {\n  return {\n    concat: function concat(fx, fy) {\n      return isLeft(fx) ? isLeft(fy) ? left(SE.concat(fx.left, fy.left)) : fx : isLeft(fy) ? fy : right(SA.concat(fx.right, fy.right));\n    }\n  };\n}\n\nexports.getValidationSemigroup = getValidationSemigroup;\n/**\n * @since 2.0.0\n */\n\nfunction getValidationMonoid(SE, SA) {\n  return {\n    concat: getValidationSemigroup(SE, SA).concat,\n    empty: right(SA.empty)\n  };\n}\n\nexports.getValidationMonoid = getValidationMonoid;\n/**\n * @since 2.0.0\n */\n\nexports.either = {\n  URI: exports.URI,\n  map: function map(ma, f) {\n    return isLeft(ma) ? ma : right(f(ma.right));\n  },\n  of: right,\n  ap: function ap(mab, ma) {\n    return isLeft(mab) ? mab : isLeft(ma) ? ma : right(mab.right(ma.right));\n  },\n  chain: function chain(ma, f) {\n    return isLeft(ma) ? ma : f(ma.right);\n  },\n  reduce: function reduce(fa, b, f) {\n    return isLeft(fa) ? b : f(b, fa.right);\n  },\n  foldMap: function foldMap(M) {\n    return function (fa, f) {\n      return isLeft(fa) ? M.empty : f(fa.right);\n    };\n  },\n  reduceRight: function reduceRight(fa, b, f) {\n    return isLeft(fa) ? b : f(fa.right, b);\n  },\n  traverse: function traverse(F) {\n    return function (ma, f) {\n      return isLeft(ma) ? F.of(left(ma.left)) : F.map(f(ma.right), right);\n    };\n  },\n  sequence: function sequence(F) {\n    return function (ma) {\n      return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n  },\n  bimap: function bimap(fea, f, g) {\n    return isLeft(fea) ? left(f(fea.left)) : right(g(fea.right));\n  },\n  mapLeft: function mapLeft(fea, f) {\n    return isLeft(fea) ? left(f(fea.left)) : fea;\n  },\n  alt: function alt(fx, fy) {\n    return isLeft(fx) ? fy() : fx;\n  },\n  extend: function extend(wa, f) {\n    return isLeft(wa) ? wa : right(f(wa));\n  },\n  chainRec: function chainRec(a, f) {\n    return ChainRec_1.tailRec(f(a), function (e) {\n      return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n  },\n  throwError: left\n};\n\nvar _a = pipeable_1.pipeable(exports.either),\n    alt = _a.alt,\n    ap = _a.ap,\n    apFirst = _a.apFirst,\n    apSecond = _a.apSecond,\n    bimap = _a.bimap,\n    chain = _a.chain,\n    chainFirst = _a.chainFirst,\n    duplicate = _a.duplicate,\n    extend = _a.extend,\n    flatten = _a.flatten,\n    foldMap = _a.foldMap,\n    map = _a.map,\n    mapLeft = _a.mapLeft,\n    reduce = _a.reduce,\n    reduceRight = _a.reduceRight,\n    fromOption = _a.fromOption,\n    fromPredicate = _a.fromPredicate,\n    filterOrElse = _a.filterOrElse;\n\nexports.alt = alt;\nexports.ap = ap;\nexports.apFirst = apFirst;\nexports.apSecond = apSecond;\nexports.bimap = bimap;\nexports.chain = chain;\nexports.chainFirst = chainFirst;\nexports.duplicate = duplicate;\nexports.extend = extend;\nexports.flatten = flatten;\nexports.foldMap = foldMap;\nexports.map = map;\nexports.mapLeft = mapLeft;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.fromOption = fromOption;\nexports.fromPredicate = fromPredicate;\nexports.filterOrElse = filterOrElse;","map":null,"metadata":{},"sourceType":"script"}